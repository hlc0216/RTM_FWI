/*A demo of 3D RTM with GPU accelaration, the input
data file is SU format, so you must set the keyword sx,sy,gx,gy.
This program can automatically malloc the grid size of model based
on the shot and receiver poisitions with a rectangle area.
The output file is also a SU format file with only one line in
the direction of inline, program will output imaging of every shot, so
I suggest you stacking this SU file to get a final imaging lines. */
/*                                                        */
/*                                                        */
/* Copyright (c), Chinese Academy of Science, Guiting Chen,2018.12.15 */
/* All rights reserved. */



#include "su.h"
#include "segy.h"
#include "header.h"
#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include <string.h>
#include <math.h>
#include <time.h>
#include <cuda_runtime.h>
/*********************** self documentation **********************/
char *sdoc[] = {
	" 								",
	" 3D reverse time migration with high performance GPU acceleration	",
	"	Author: Guiting Chen, Chinese Academy of Science,2018.12.09	",
	"								",
	NULL };

#define LOOKFAC 2       /* Look ahead factor for npfaro   */
#define PFA_MAX 720720  /* Largest allowed nfft	   */
#ifndef PI
#define PI 	3.1415926535
#endif

#ifndef EPS
#define EPS	0.0000000001
#endif
#define BlockSize1 	16// tile size in 1st-axis
#define BlockSize2 	16// tile size in 2nd-axis
#define BlockSize3 	16// tile size in 3nd-axis
#define radius 		4// half of the order in space

void sf_check_gpu_error(const char *msg)
/*< check GPU errors >*/
{
	cudaError_t err = cudaGetLastError();
	if (cudaSuccess != err) {
		warn("Cuda error: %s: %s", msg, cudaGetErrorString(err));
		exit(0);
	}
}

__constant__ float stencil[radius + 1] = { -205.0 / 72.0,8.0 / 5.0,-1.0 / 5.0,8.0 / 315.0,-1.0 / 560.0 };

__global__ void cuda_ricker_wavelet(float *wlt, float fm, float dt, int nt)
/*< generate ricker wavelet with time deley >*/
{
	int it = threadIdx.x + blockDim.x*blockIdx.x;
	if (it<nt) {
		float tmp = PI*fm*fabsf(it*dt - 1.0 / fm);//delay the wavelet to exhibit all waveform
		tmp *= tmp;
		wlt[it] = (1.0 - 2.0*tmp)*expf(-tmp);// ricker wavelet at time: t=nt*dt
	}
}

__global__ void cuda_init_bell3(float *bell)
/*< initialize Gaussian bell function>*/
{
	int i1 = threadIdx.x;
	int i2 = threadIdx.y;
	int i3;
	int id = i1 + i2*(2 * nbell + 1);
	float s = 0.5*nbell;
	bell[id] = expf(-((i1 - nbell)*(i1 - nbell) + (i2 - nbell)*(i2 - nbell)) / s);
}


__global__ void cuda_set_sg(int *szxy, int szbeg, int sxbeg, int sybeg, int jsz, int jsx, int jsy, int ns, int nz, int nx, int nb)
/*< set the positions of sources and geophones in whole domain >*/
{
	int id = threadIdx.x + blockDim.x*blockIdx.x;
	int nbr = nb + radius;
	int nn1 = nz + 2 * nbr;
	int nn2 = nx + 2 * nbr;
	if (id<ns) szxy[id] = (szbeg + id*jsz + nbr) + nn1*(sxbeg + id*jsx + nbr) + nn1*nn2*(sybeg + id*jsy + nbr);
}


__global__ void cuda_set_ss(int *szxy, int ns_x, int ns_y, int szbeg, int sxbeg, int sybeg, int jsx, int jsy, int ns, int nz, int nx, int nb)
/*< set the positions of sources and geophones in whole domain >*/
{
	int i, j, id;
	int nbr = nb + radius;
	int nn1 = nz + 2 * nbr;
	int nn2 = nx + 2 * nbr;
	for (i = 0; i<ns_y; i++)
		for (j = 0; j < ns_x; j++)
		{
			id = j + i * 10;
			szxy[id] = (szbeg + nbr) + nn1*(sxbeg + j*jsx + nbr) + nn1*nn2*(sybeg + i*jsy + nbr);
		}



}


__global__ void cuda_add_source(bool add, float *p, float *source, int *szxy, int ns)
/*< add/subtract sources: length of source[]=ns, index stored in szxy[] >*/
{
	int id = threadIdx.x + blockIdx.x*blockDim.x;

	if (id<ns) {
		if (add) {
			p[szxy[id]] += source[id];
		}
		else {
			p[szxy[id]] -= source[id];
		}
	}
}

//n1=nz+2*nb; n2=nx+2*nb; n3=ny+2*nb;
__global__ void cuda_step_fd3d(float *p0, float *p1, float *vv, float _dz2, float _dx2, float _dy2, int n1, int n2, int n3)
/*< step forward: 3-D FD, order=8 >*/
{
	bool validr = true;
	bool validw = true;
	const int gtid1 = blockIdx.x * blockDim.x + threadIdx.x;
	const int gtid2 = blockIdx.y * blockDim.y + threadIdx.y;
	const int ltid1 = threadIdx.x;
	const int ltid2 = threadIdx.y;
	const int work1 = blockDim.x;
	const int work2 = blockDim.y;
	__shared__ float tile[BlockSize2 + 2 * radius][BlockSize1 + 2 * radius];

	const int stride2 = n1 + 2 * radius;
	const int stride3 = stride2 * (n2 + 2 * radius);

	int inIndex = 0;
	int outIndex = 0;

	// Advance inputIndex to start of inner volume
	inIndex += radius * stride2 + radius;

	// Advance inputIndex to target element
	inIndex += gtid2 * stride2 + gtid1;

	float infront[radius];
	float behind[radius];
	float current;

	const int t1 = ltid1 + radius;
	const int t2 = ltid2 + radius;

	// Check in bounds
	if ((gtid1 >= n1 + radius) || (gtid2 >= n2 + radius)) validr = false;
	if ((gtid1 >= n1) || (gtid2 >= n2)) validw = false;

	// Preload the "infront" and "behind" data
	for (int i = radius - 2; i >= 0; i--)
	{
		if (validr) behind[i] = p1[inIndex];
		inIndex += stride3;
	}

	if (validr)	current = p1[inIndex];

	outIndex = inIndex;
	inIndex += stride3;

	for (int i = 0; i < radius; i++)
	{
		if (validr) infront[i] = p1[inIndex];
		inIndex += stride3;
	}

	// Step through the zx-planes
#pragma unroll 9
	for (int i3 = 0; i3 < n3; i3++)
	{
		// Advance the slice (move the thread-front)
		for (int i = radius - 1; i > 0; i--) behind[i] = behind[i - 1];

		behind[0] = current;
		current = infront[0];
#pragma unroll 4
		for (int i = 0; i < radius - 1; i++) infront[i] = infront[i + 1];

		if (validr) infront[radius - 1] = p1[inIndex];

		inIndex += stride3;
		outIndex += stride3;
		__syncthreads();

		// Update the data slice in the local tile
		// Halo above & below
		if (ltid2 < radius)
		{
			tile[ltid2][t1] = p1[outIndex - radius * stride2];
			tile[ltid2 + work2 + radius][t1] = p1[outIndex + work2 * stride2];
		}

		// Halo left & right
		if (ltid1 < radius)
		{
			tile[t2][ltid1] = p1[outIndex - radius];
			tile[t2][ltid1 + work1 + radius] = p1[outIndex + work1];
		}

		tile[t2][t1] = current;
		__syncthreads();

		// Compute the output value
		float c1, c2, c3;
		c1 = c2 = c3 = stencil[0] * current;
#pragma unroll 4
		for (int i = 1; i <= radius; i++)
		{
			c1 += stencil[i] * (tile[t2][t1 - i] + tile[t2][t1 + i]);
			c2 += stencil[i] * (tile[t2 - i][t1] + tile[t2 + i][t1]);
			c3 += stencil[i] * (infront[i - 1] + behind[i - 1]);
		}
		c1 *= _dz2;
		c2 *= _dx2;
		c3 *= _dy2;
		if (validw) p0[outIndex] = 2.0*p1[outIndex] - p0[outIndex] + vv[outIndex] * (c1 + c2 + c3);
	}
}



void velocity_transform(float*vv, float dt, float dz, float dx, float dy, int nz, int nx, int ny, int nb)
/*< velocity transform: vv<--vv^2 >*/
{
	int i1, i2, i3, nbr, nn1, nn2, nn3;
	float a;

	nbr = radius + nb;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;

	for (i3 = 0; i3<nn3; i3++)
		for (i2 = 0; i2<nn2; i2++)
			for (i1 = 0; i1<nn1; i1++)
			{
				a = vv[i1 + nn1*i2 + nn1*nn2*i3] * dt;
				vv[i1 + nn1*i2 + nn1*nn2*i3] = a*a;
			}
}

void random_boundary(float *v0, float *vv, int nz, int nx, int ny, int nb)
/*< initialize velocity using random boundary condition >*/
{
	int i1, i2, i3, nbr, nn1, nn2, nn3, a;

	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;

	/* top and bottom */
	for (i3 = 0; i3<nn3; i3++)
		for (i2 = 0; i2<nn2; i2++)
			for (i1 = 0; i1<nbr; i1++)
			{
				a = (int)vv[i1 + nn1*i2 + nn1*nn2*i3];
				vv[i1 + nn1*i2 + nn1*nn2*i3] -= float(rand() % a) / nbr*(nbr - i1);
				a = (int)vv[(nn1 - 1 - i1) + nn1*i2 + nn1*nn2*i3];
				vv[(nn1 - 1 - i1) + nn1*i2 + nn1*nn2*i3] -= float(rand() % a) / nbr*(nbr - i1);
			}

	/* left and right */
	for (i3 = 0; i3<nn3; i3++)
		for (i2 = 0; i2<nbr; i2++)
			for (i1 = 0; i1<nn1; i1++)
			{
				a = (int)vv[i1 + nn1*i2 + nn1*nn2*i3];
				vv[i1 + nn1*i2 + nn1*nn2*i3] -= float(rand() % a) / nbr*(nbr - i2);
				a = (int)vv[i1 + nn1*(nn2 - i2 - 1) + nn1*nn2*i3];
				vv[i1 + nn1*(nn2 - i2 - 1) + nn1*nn2*i3] -= float(rand() % a) / nbr*(nbr - i2);
			}

	/* front and rear */
	for (i3 = 0; i3<nbr; i3++)
		for (i2 = 0; i2<nn2; i2++)
			for (i1 = 0; i1<nn1; i1++)
			{
				a = (int)vv[i1 + nn1*i2 + nn1*nn2*i3];
				vv[i1 + nn1*i2 + nn1*nn2*i3] -= float(rand() % a) / nbr*(nbr - i3);
				a = (int)vv[i1 + nn1*i2 + nn1*nn2*(nn3 - 1 - i3)];
				vv[i1 + nn1*i2 + nn1*nn2*(nn3 - 1 - i3)] -= float(rand() % a) / nbr*(nbr - i3);
			}

}

void extend3d(float *v0, float *vv, int nz, int nx, int ny, int nb)
/*< extend 3d velocity model >*/
{
	int i1, i2, i3, nbr, nn1, nn2, nn3;

	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;

	/* central zone */
	for (i3 = 0; i3<ny; i3++)
		for (i2 = 0; i2<nx; i2++)
			for (i1 = 0; i1<nz; i1++)
			{
				vv[(i1 + nbr) + nn1*(i2 + nbr) + nn1*nn2*(i3 + nbr)] = v0[i1 + nz*i2 + nz*nx*i3];
			}

	/* top and bottom */
	for (i3 = 0; i3<nn3; i3++)
		for (i2 = 0; i2<nn2; i2++)
			for (i1 = 0; i1<nbr; i1++)
			{
				vv[i1 + nn1*i2 + nn1*nn2*i3] = vv[nbr + nn1*i2 + nn1*nn2*i3];
				vv[(nn1 - 1 - i1) + nn1*i2 + nn1*nn2*i3] = vv[(nn1 - 1 - nbr) + nn1*i2 + nn1*nn2*i3];
			}

	/* left and right */
	for (i3 = 0; i3<nn3; i3++)
		for (i2 = 0; i2<nbr; i2++)
			for (i1 = 0; i1<nn1; i1++)
			{
				vv[i1 + nn1*i2 + nn1*nn2*i3] = vv[i1 + nn1*nbr + nn1*nn2*i3];
				vv[i1 + nn1*(nn2 - i2 - 1) + nn1*nn2*i3] = vv[i1 + nn1*(nn2 - nbr - 1) + nn1*nn2*i3];
			}

	/* front and rear */
	for (i3 = 0; i3<nbr; i3++)
		for (i2 = 0; i2<nn2; i2++)
			for (i1 = 0; i1<nn1; i1++)
			{
				vv[i1 + nn1*i2 + nn1*nn2*i3] = vv[i1 + nn1*i2 + nn1*nn2*nbr];
				vv[i1 + nn1*i2 + nn1*nn2*(nn3 - 1 - i3)] = vv[i1 + nn1*i2 + nn1*nn2*(nn3 - nbr - 1)];
			}
}
void window3d(float *a, float *b, int nz, int nx, int ny, int nb)
/*< window a 3d subvolume >*/
{
	int i1, i2, i3, nbr, nn1, nn2;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;

	for (i3 = 0; i3<ny; i3++)
		for (i2 = 0; i2<nx; i2++)
			for (i1 = 0; i1<nz; i1++)
			{
				a[i1 + nz*i2 + nz*nx*i3] = b[(i1 + nbr) + nn1*(i2 + nbr) + nn1*nn2*(i3 + nbr)];
			}
}

void window2d(float *a, float *b, int nz, int ny, int nb)
/*< window a 2d subvolume >*/
{
	int i1, i2, i3, nbr, nn1, nn2;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = ny + 2 * nbr;

	for (i2 = 0; i2<ny; i2++)
		for (i1 = 0; i1<nz; i1++)
		{
			a[i1 + nz*i2] = b[(i1 + nbr) + nn1*(i2 + nbr)];
		}
}


__global__ void apply_sponge_tb(float *sp0, float *abc, int nz, int nx, int ny, int nb)
/*< extend 3d velocity model >*/
{
	int i2 = blockIdx.x*blockDim.x + threadIdx.x;
	int i3 = blockIdx.y*blockDim.y + threadIdx.y;
	int nbr, nn1, nn2, nn3, i, NN;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	NN = nn1*nn2*nn3;
	int id = i2*nn1 + i3*nn1*nn2;
	for (i = 0; i < nbr; i++)
	{
		if (id + i < NN && id + nn1 - 1 - i < NN)
		{
			sp0[id + i] *= abc[i];
			sp0[id + nn1 - 1 - i] *= abc[i];
		}
	}
}


__global__ void apply_sponge_lr(float *sp0, float *abc, int nz, int nx, int ny, int nb)
/*< extend 3d velocity model >*/
{
	int i1 = blockIdx.x*blockDim.x + threadIdx.x;
	int i3 = blockIdx.y*blockDim.y + threadIdx.y;
	int nbr, nn1, nn2, nn3, i, NN;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	NN = nn1*nn2*nn3;
	int id = i1 + i3*nn1*nn2;
	for (i = 0; i < nbr; i++)
	{
		if (id + i*nn1 < NN && id + (nn2 - 1 - i)*nn1 < NN)
		{
			sp0[id + i*nn1] *= abc[i];
			sp0[id + (nn2 - 1 - i)*nn1] *= abc[i];
		}
	}
}

__global__ void apply_sponge_fr(float *sp0, float *abc, int nz, int nx, int ny, int nb)
/*< extend 3d velocity model >*/
{
	int i1 = blockIdx.x*blockDim.x + threadIdx.x;
	int i2 = blockIdx.y*blockDim.y + threadIdx.y;

	int nbr, nn1, nn2, nn3, i, NN;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	NN = nn1*nn2*nn3;

	int id = i1 + i2*nn1;
	for (i = 0; i < nbr; i++)
	{
		if (id + i*nn1*nn2 < NN && id + (nn3 - 1 - i)*nn1*nn2 < NN)
		{
			sp0[id + i*nn1*nn2] *= abc[i];
			sp0[id + (nn3 - 1 - i)*nn1*nn2] *= abc[i];
		}
	}
}




__global__ void cuda_rw_innertb(float *innertb, float *p, int nz, int nx, int ny, int nb, bool read)
/*< read and write the inner computation zone boundary coefficients from and into RAM along z direction
read==flase, write/save boundary; read==true, read the boundary >*/
{

	int i2 = blockIdx.x*blockDim.x + threadIdx.x;
	int i3 = blockIdx.y*blockDim.y + threadIdx.y;

	int nbr, nn1, nn2, nn3, i, NN;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	NN = nn1*nn2*nn3;
	int id = nbr + (i2 + nbr)*nn1 + (i3 + nbr)*nn1*nn2;
	int idp = i2 + i3*nx;

	if (i2 < nx && i3 < ny)
	{
		if (read)
		{
			p[id] = innertb[idp];
			p[id + nz - 1] = innertb[idp + (nx*ny)];
		}
		else
		{
			innertb[idp] = p[id];
			innertb[idp + (nx*ny)] = p[id + nz - 1];
		}
	}

}

__global__ void cuda_rw_innerlr(float *innerlr, float *p, int nz, int nx, int ny, int nb, bool read)
/*< read and write the inner computation zone boundary coefficients from and into RAM along z direction
read==flase, write/save boundary; read==true, read the boundary >*/
{

	int i1 = blockIdx.x*blockDim.x + threadIdx.x;
	int i3 = blockIdx.y*blockDim.y + threadIdx.y;

	int nbr, nn1, nn2, nn3, i, NN;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	NN = nn1*nn2*nn3;
	int id = nbr + i1 + nbr*nn1 + (i3 + nbr)*nn1*nn2;
	int idp = i1 + i3*nz;

	if (i1 < nz && i3 < ny)
	{
		if (read)
		{
			p[id] = innerlr[idp];
			p[id + (nx - 1)*nn1] = innerlr[idp + (ny*nz)];
		}
		else
		{
			innerlr[idp] = p[id];
			innerlr[idp + (ny*nz)] = p[id + (nx - 1)*nn1];
		}
	}


}


__global__ void cuda_rw_innerfr(float *innerfr, float *p, int nz, int nx, int ny, int nb, bool read)
/*< read and write the inner computation zone boundary coefficients from and into RAM along z direction
read==flase, write/save boundary; read==true, read the boundary >*/
{

	int i1 = blockIdx.x*blockDim.x + threadIdx.x;
	int i2 = blockIdx.y*blockDim.y + threadIdx.y;

	int nbr, nn1, nn2, nn3, i, NN;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	NN = nn1*nn2*nn3;
	int id = nbr + i1 + (nbr + i2)*nn1 + nbr*nn1*nn2;
	int idp = i1 + i2*nz;

	if (i1 < nz && i2 < nx)
	{
		if (read)
		{
			p[id] = innerfr[idp];
			p[id + (ny - 1)*nn1*nn2] = innerfr[idp + (nx*nz)];
		}
		else
		{
			innerfr[idp] = p[id];
			innerfr[idp + (nx*nz)] = p[id + (ny - 1)*nn1*nn2];
		}
	}
}

__global__ void cuda_abc(float*abc, int nbr)
{
	int id = threadIdx.x + blockDim.x*blockIdx.x;
	float t = 0.015*(nbr - 1 - id);
	if (id < nbr) abc[id] = expf(-t*t);
}

__global__ void cuda_set_gg(int *gzxy, int ng, int nz, int nx, int ny, int nb)
/*< set the positions of sources and geophones in whole domain >*/
{
	int i2 = blockIdx.x*blockDim.x + threadIdx.x;
	int i3 = blockIdx.y*blockDim.y + threadIdx.y;

	int nbr, nn1, nn2, nn3, i, NN;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	NN = nn1*nn2*nn3;
	int id = nbr + (i2 + nbr)*nn1 + (i3 + nbr)*nn1*nn2;
	int idp = i2 + i3*nx;
	if (idp<ng) gzxy[idp] = id;

}


__global__ void cuda_record(float*p, float *seis_kt, int *Gxz, int ng)
{
	int id = threadIdx.x + blockDim.x*blockIdx.x;
	if (id<ng) seis_kt[id] = p[Gxz[id]];
}




__global__ void cuda_cross_correlate(float *Isg, float *Iss, float *sp, float *gp, int nz, int nx, int ny, int nb)
/*< perform cross-correlation >*/
{

	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;


	int nbr, nn1, nn2, nn3, i, NN, i3;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	for (i3 = 0; i3 < ny; i3++)
	{
		int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;
		if (i1 >= nbr && i1<nn1 - nbr && i2 >= nbr && i2<nn2 - nbr)
		{
			float ps = sp[id];
			float pg = gp[id];
			Isg[id] += ps*pg;
			Iss[id] += ps*ps;
		}

	}
}


__global__ void cuda_cross_correlate_oneinlin(float *Isg, float *Iss, float *sp, float *gp, int nz_s, int nx_s, int ny_s, int nz_g, int nx_g, int ny_g, int index_sx_xd, int index_gx_xd, int nb)
/*< perform cross-correlation >*/
{

	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i3 = threadIdx.y + blockDim.y*blockIdx.y;


	int nbr, nn1_s, nn2_s, nn3_s, nn1_g, nn2_g, nn3_g, i, NN_s, NN_g, i3;
	nbr = nb + radius;
	nn1_s = nz_s + 2 * nbr;
	nn2_s = nx_s + 2 * nbr;
	nn3_s = ny_s + 2 * nbr;
	nn1_g = nz_s + 2 * nbr;
	nn2_g = nx_g + 2 * nbr;
	nn3_g = ny_g + 2 * nbr;

	int id_s = i1 + (index_sx_xd + nbr)*nn1_s + (i3)*nn1_s*nn2_s;
	int id_g = i1 + (index_gx_xd + nbr)*nn1_g + (i3)*nn1_g*nn2_g;
	int id = i1 + i3*nn1_s;
	if (i1 >= nbr && i1 < nn1_s - nbr && i3 >= nbr && i3 < nn3_s - nbr)
	{
		float ps = sp[id_s];
		float pg = gp[id_g];
		Isg[id] += ps*pg;
		Iss[id] += ps*ps;
	}

}



__global__ void cuda_cross_correlate2(float *Isg, float *Iss, float *sp, float *gp, int *nsg, int *nss, int nz, int nx, int ny, int nb)
/*< perform cross-correlation >*/
{

	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;


	int nbr, nn1, nn2, nn3, i, NN, i3;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	for (i3 = 0; i3 < ny; i3++)
	{
		int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;
		if (i1 >= nbr && i1<nn1 - nbr && i2 >= nbr && i2<nn2 - nbr)
		{
			float ps = sp[id];
			float pg = gp[id];
			if (ps*pg != 0) nsg[id]++;
			if (ps*ps != 0) nss[id]++;
			Isg[id] += ps*pg;
			Iss[id] += ps*ps;
		}

	}
}





__global__ void cuda_imaging(float *Isg, float *Iss, float *I1, float *I2, int nz, int nx, int ny, int nb)
/*< imaging condition with and without illumination compensation >*/
{
	int nbr, nn1, nn2, nn3, i, NN, i3;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;

	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;
	for (i3 = 0; i3 < ny; i3++)
	{
		int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;
		if (i1 >= nbr && i1<nn1 - nbr && i2 >= nbr && i2<nn2 - nbr)
		{
			I1[id] += Isg[id];		// correlation imaging condition
			I2[id] += Isg[id] / (Iss[id] + EPS);  // image normalization with illumination
		}

	}
}

__global__ void cuda_imaging22(float *Isg, float *Iss, float *I1, float *I2, int nz, int nx, int ny, int nb)
/*< imaging condition with and without illumination compensation >*/
{
	int nbr, nn1, nn2, nn3, i, NN, i3;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;

	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;
	for (i3 = 0; i3 < ny; i3++)
	{
		int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;
		if (i1 >= nbr && i1<nn1 - nbr && i2 >= nbr && i2<nn2 - nbr)
		{
			I1[id] = Isg[id];		// correlation imaging condition
			I2[id] = Isg[id] / (Iss[id] + EPS);  // image normalization with illumination
		}

	}
}



__global__ void cuda_imaging2(float *Isg, float *Iss, float *I1, float *I2, int *nsg, int *nss, int nz, int nx, int ny, int nb)
/*< imaging condition with and without illumination compensation >*/
{
	int nbr, nn1, nn2, nn3, i, NN, i3;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;

	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;
	for (i3 = 0; i3 < ny; i3++)
	{
		int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;
		if (i1 >= nbr && i1<nn1 - nbr && i2 >= nbr && i2<nn2 - nbr)
		{
			if (nsg[id] > 0) Isg[id] = Isg[id] / nsg[id];
			if (nss[id] > 0) Iss[id] = Iss[id] / nss[id];
			I1[id] += Isg[id];		// correlation imaging condition
			I2[id] += Isg[id] / (Iss[id] + EPS);  // image normalization with illumination
		}

	}
}


__global__ void cuda_imaging_oneinlin(float *Isg, float *Iss, float *I1, float *I2, int nz_s, int nx_s, int ny_s, int nz_g, int nx_g, int ny_g, int index_sx_xd, int index_gx_xd, int nb)
/*< perform cross-correlation >*/
{

	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i3 = threadIdx.y + blockDim.y*blockIdx.y;


	int nbr, nn1_s, nn2_s, nn3_s, nn1_g, nn2_g, nn3_g, i, NN_s, NN_g, i3;
	nbr = nb + radius;
	nn1_s = nz_s + 2 * nbr;
	nn2_s = nx_s + 2 * nbr;
	nn3_s = ny_s + 2 * nbr;
	nn1_g = nz_s + 2 * nbr;
	nn2_g = nx_g + 2 * nbr;
	nn3_g = ny_g + 2 * nbr;

	//int id_s = i1 + (index_sx_xd + nbr)*nn1_s + (i3)*nn1_s*nn2_s;
	//int id_g = i1 + (index_gx_xd + nbr)*nn1_g + (i3)*nn1_g*nn2_g;
	int id = i1 + i3*nn1_s;
	if (i1 >= nbr && i1 < nn1_s - nbr && i3 >= nbr && i3 < nn3_s - nbr)
	{
		I1[id] = Isg[id];		// correlation imaging condition
		I2[id] = Isg[id] / (Iss[id] + EPS);  // image normalization with illumination
	}

	/*
	int nbr, nn1, nn2, nn3, i, NN, i3;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;

	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;
	for (i3 = 0; i3 < ny; i3++)
	{
	int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;
	if (i1 >= nbr && i1<nn1 - nbr && i2 >= nbr && i2<nn2 - nbr)
	{
	I1[id] = Isg[id];		// correlation imaging condition
	I2[id] = Isg[id] / (Iss[id] + EPS);  // image normalization with illumination
	}

	}
	*/
}

__global__ void cuda_taper(float *I1, float *I2, int gx, int gy, int length, int dis1, int nz, int nx, int ny, int nb)
/*< imaging condition with and without illumination compensation >*/
{
	int nbr, nn1, nn2, nn3, i, NN, i3, sb;
	int sx;
	int sy;
	float taper = 0;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	//int middle = (int)( (gx - sx)*(gx - sx));
	int dis2 = 0;
	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;
	for (i3 = 0; i3 < ny; i3++)
	{
		int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;


		if (i1 >= nbr && i1<nn1 - nbr && i2 >= nbr && i2<nn2 - nbr && abs(gx - i2))
		{
			sx = i2 - nbr;
			sy = i3;
			dis2 = (int)(sqrt(1.0*((sx - gx)*(sx - gx) + (sy - gy)*(sy - gy))));
			if (dis2 > length && dis2<dis1)
			{
				taper = 1;
			}
			if (dis2 <= length)
			{
				taper = 1;

			}
			if (dis2 > dis1 - length && dis2 <dis1)
			{
				taper = 1.0*(dis1 - dis2) / (1.0*(length - 1));
				//taper =1.0;
			}
			if (dis2>dis1)
			{
				taper = 0;
			}
			I1[id] *= taper;		// correlation imaging condition
			I2[id] *= taper;  // image normalization with illumination


		}

	}
}

__global__ void cuda_taper2(float *I1, float *I2, int gx, int gy, float length, float dis1, int nz, int nx, int ny, int nb, int flagk, float k1, int z_beg)
/*< imaging condition with and without illumination compensation >*/
{
	int nbr, nn1, nn2, nn3, i, NN, i3, sb;
	int sx, sy, sz;
	int flag = 0;
	float taper = 0;
	float taper2 = 0;
	float taper3 = 0;
	float dis3 = 0;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	//int middle = (int)( (gx - sx)*(gx - sx));
	int dis2 = 0;
	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;
	for (i3 = 0; i3 < ny; i3++)
	{
		int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;


		if (i1 >= nbr && i1<nn1 - nbr && i2 >= nbr && i2<nn2 - nbr && abs(gx - i2))
		{
			sx = i2 - nbr;
			sy = i3;


			dis2 = (sqrt(1.0*((sx - gx)*(sx - gx) + 1.0*(sy - gy)*(sy - gy))));
			if (sz>z_beg + 5 && dis2 <= dis1)
			{
				dis3 = (1.0*(sz - z_beg) / (1.0*(2 * sz - z_beg))*dis1);
				if (dis2 >= dis3)
				{
					//taper3 = 1.0*((dis1 - dis2)) / (1.0*(dis1 - dis3));
					if (dis2 - dis3 <= length)
					{
						taper3 = 1.0*(length + dis3 - dis2) / (1.0*length);
						taper3 = 0;
					}
					else
					{
						taper3 = 0;
					}
				}
				else
				{
					taper3 = 0;
				}
			}
			else
			{
				taper3 = 0;
			}
			if ((k1*(sx - gx) + gy*1.0) > 1.0*sy)
			{
				flag = 3;
			}
			else
			{
				flag = -3;
			}
			if (flag == flagk)
			{
				taper2 = 1.0;

			}
			dis2 = 10 * (sqrt(1.0*((sx - gx)*(sx - gx) + (sy - gy)*(sy - gy))));
			if (dis2 > length && dis2<dis1)
			{
				taper = 1;
			}
			if (dis2 <= length)
			{
				taper = 1;

			}
			if (dis2 > dis1 - length && dis2 <dis1)
			{
				taper = 1.0*(dis1 - dis2) / (1.0*(length - 1));
				//taper =1.0;
			}
			if (dis2>dis1)
			{
				taper = 0;
			}
			I1[id] *= taper*taper2;		// correlation imaging condition
			I2[id] *= taper*taper2;  // image normalization with illumination


		}

	}
}

__global__ void cuda_taper3(float *I1, float *I2, int gx, int gy, int length, int dis1, int nz, int nx, int ny, int nb, int flagk, float k1, int z_beg)
/*< imaging condition with and without illumination compensation >*/
{
	int nbr, nn1, nn2, nn3, i, NN, i3, sb;
	int sx, sy, sz;
	int flag = 0;
	float taper = 0;
	float taper2 = 0;
	float taper3 = 0;
	float dis3 = 0;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	//int middle = (int)( (gx - sx)*(gx - sx));
	int dis2 = 0;
	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;
	for (i3 = 0; i3 < ny; i3++)
	{
		int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;


		if (i1 >= nbr && i1<nn1 - nbr && i2 >= nbr && i2<nn2 - nbr && abs(gx - i2))
		{
			sx = i2 - nbr;
			sy = i3;
			sz = i1 - nbr;

			dis2 = 10 * (sqrt(1.0*((sx - gx)*(sx - gx) + 1.0*(sy - gy)*(sy - gy))));
			if (sz>z_beg + 5)
			{
				dis3 = (1.0*(sz - z_beg) / (1.0*(2 * sz - z_beg))*dis1);
				if (dis2 >= dis3)
				{
					//taper3 = 1.0*((dis1 - dis2)) / (1.0*(dis1 - dis3));
					if (dis2 - dis3 <= length)
					{
						taper3 = 1.0*(length + dis3 - dis2) / (1.0*length);
						//taper3 = 0;
					}
					else
					{
						taper3 = 0;
					}
				}
				else
				{
					taper3 = 1;
				}
			}
			else
			{
				taper3 = 0;
			}



			if ((k1*(sx - gx) + gy*1.0) > 1.0*sy)
			{
				flag = 3;
			}
			else
			{
				flag = -3;
			}
			if (flag == flagk)
			{
				taper2 = 1.0;

			}
			dis2 = 10 * (sqrt(1.0*((sx - gx)*(sx - gx) + (sy - gy)*(sy - gy))));
			if (dis2 > length && dis2<dis1)
			{
				taper = 1;
			}
			if (dis2 <= length)
			{
				taper = 1;

			}
			if (dis2 > dis1 - length && dis2 <dis1)
			{
				taper = 1.0*(dis1 - dis2) / (1.0*(length - 1));
				//taper =1.0;
			}
			if (dis2>dis1)
			{
				taper = 0;
			}
			I1[id] *= taper*taper2;		// correlation imaging condition
			I2[id] *= taper*taper2;  // image normalization with illumination


		}

	}
}



__global__ void cuda_laplace_filter2d(float *Img, float *laplace, float _dz, float _dy, int nb, int nz, int ny)
{
	
	int nbr, nn1, nn2, nn3, i, NN, i3;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn3 = ny + 2 * nbr;
	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i3 = threadIdx.y + blockDim.y*blockIdx.y;
	int id = i1 + i3*nn1;
	float diff1 = 0.0f;
	float diff3 = 0.0f;
	if (i1 >= nbr + 1 && i1<nn1 - nbr - 1 && i3 >= nbr + 1 && i3<nn3 - nbr - 1)
	{
		diff1 = Img[id + 1] - 2.0*Img[id] + Img[id - 1];
		diff3 = Img[id + nn1] - 2.0*Img[id] + Img[id - nn1];
		//Img[id + nn1*nn2] - 2.0*Img[id] + Img[id - nn1*nn2];
	}
	laplace[id] = _dz*_dz*diff1 + _dy*_dy*diff3;
}

__global__ void cuda_laplace_filter3d(float *Img, float *laplace, float _dz, float _dx, float _dy, int nz, int nx, int ny, int nb)
{
	int nbr, nn1, nn2, nn3, i, NN, i3;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	int i1 = threadIdx.x + blockDim.x*blockIdx.x;
	int i2 = threadIdx.y + blockDim.y*blockIdx.y;
	float diff1 = 0.0f;
	float diff2 = 0.0f;
	float diff3 = 0.0f;
	for (i3 = 0; i3 < ny; i3++)
	{
		int id = i1 + i2*nn1 + (i3 + nbr)*nn1*nn2;

		if (i1 >= nbr + 1 && i1<nn1 - nbr - 1 && i2 >= nbr + 1 && i2<nn2 - nbr - 1)
		{
			diff1 = Img[id + 1] - 2.0*Img[id] + Img[id - 1];
			diff2 = Img[id + nn1] - 2.0*Img[id] + Img[id - nn1];
			diff3 = 0;//Img[id + nn1*nn2] - 2.0*Img[id] + Img[id - nn1*nn2];
		}
		laplace[id] = _dz*_dz*diff1 + _dx*_dx*diff2 + _dy*_dy*diff3;
	}



}


// mute the direct arrival according to the given velocity vmute
__global__ void cuda_mute(float *seis_kt, int *d_szxy, int *d_gzxy, int kt, int ntd, float vmute, float dt, float dz, float dx, float dy, int nz, int nx, int ny, int nb, int ng, int ns)
{

	int i2 = blockIdx.x*blockDim.x + threadIdx.x;
	int i3 = blockIdx.y*blockDim.y + threadIdx.y;

	int nbr, nn1, nn2, nn3, i, NN;
	nbr = nb + radius;
	nn1 = nz + 2 * nbr;
	nn2 = nx + 2 * nbr;
	nn3 = ny + 2 * nbr;
	NN = nn1*nn2*nn3;
	int idp = i2 + i3*nx;
	int dis_sy = d_szxy[0] / (nn1*nn2) - nbr;
	int dis_sx = (d_szxy[0] % (nn1*nn2)) / nn1 - nbr;
	int dis_sz = (d_szxy[0] % (nn1*nn2)) % nn1 - nbr;

	int dis_gy = d_gzxy[idp] / (nn1*nn2) - nbr;
	int dis_gx = (d_gzxy[idp] % (nn1*nn2)) / nn1 - nbr;
	int dis_gz = (d_gzxy[idp] % (nn1*nn2)) % nn1 - nbr;


	float a = 1.0*dx*abs(dis_sx - dis_gx);
	float b = 1.0*dz*abs(dis_sz - dis_gz);
	float c = 1.0*dy*abs(dis_sy - dis_gy);
	float t0 = sqrtf(a*a + b*b + c*c) / vmute;
	int ktt = int(t0 / dt) + ntd;// ntd is manually added to obtain the best muting effect.
	if (idp<ng && kt<ktt) seis_kt[idp] = 0.0;
}

__global__ void cuda_set_gzxy(int *szxy, int index_sz, int index_sx, int index_sy, int is, int nz, int nx, int ny, int nb)
/*< set the positions of sources and geophones in whole domain >*/
{
	int i, j, id;
	int nbr = nb + radius;
	int nn1 = nz + 2 * nbr;
	int nn2 = nx + 2 * nbr;
	szxy[is] = (index_sz + nbr) + nn1*(index_sx + nbr) + nn1*nn2*(index_sy + nbr);

}

__global__ void cuda_set_szxy(int *szxy, int index_sz, int index_sx, int index_sy, int is, int nz, int nx, int ny, int nb)
/*< set the positions of sources and geophones in whole domain >*/
{
	int i, j, id;
	int nbr = nb + radius;
	int nn1 = nz + 2 * nbr;
	int nn2 = nx + 2 * nbr;
	szxy[is] = (index_sz + nbr) + nn1*(index_sx + nbr) + nn1*nn2*(index_sy + nbr);

}

void matrix_transpose(float *matrix, float *trans, int n1, int n2)
/*< matrix transpose: matrix tansposed to be trans >*/
{
	int i1, i2;

	for (i2 = 0; i2<n2; i2++)
		for (i1 = 0; i1<n1; i1++)
			trans[i2 + n2*i1] = matrix[i1 + n1*i2];
}




/* Prototype of functions used internally */

segy intrace; 	/* input traces */
segy outtrace;	/* migrated output traces */

int
main(int argc, char **argv)
{
	cudaEvent_t start, stop;
	float mstimer;
	cudaEventCreate(&start);
	cudaEventCreate(&stop);
	FILE *tracefp = NULL;	/* temp file to hold traces*/
	FILE *hfp = NULL;		/* temp file to hold trace headers */
	initargs(argc, argv);
	requestdoc(0);
	hfp = etmpfile();
	bool verb;
	int nz, nx, ny, nb, nbr, nzb, nxb, nyb, nnz, nnx, nny, ns = 0, ng = 0, nt, kt, it, is, szbeg, sxbeg, sybeg, jsz, jsx, jsy, N, il, igg, i_sx, i_sy, i_x, i_y, iline;
	int nz_s, nx_s, ny_s, nxb_s, nyb_s, nzb_s, nxb_g, nyb_g, nzb_g, nnz_s, nnx_s, nny_s, nnz_g, nnx_g, nny_g, N_s, N_g;
	int nz_g, nx_g, ny_g;
	int i_x_s, i_y_s, i_x_g, i_y_g;
	int i_x_s_beg, i_y_s_beg, i_x_g_beg, i_y_g_beg;
	int i_x_image;
	int index_sx_image, index_gx_image;
	int x_beg, y_beg;
	int x_image, y_image;
	int x_min, y_min, x_max, y_max;
	int start_line;
	int line_range;
	int line_last;
	int line_start;
	int ncdp;
	int ninline;
	int slice = 0;
	int nt_image;


	int *d_szxy, *d_gzxy;
	float dz, dx, dy, fm, dt, _dz2, _dx2, _dy2;
	int ddz, ddx, ddy;
	float *v0, *vv, *d_wlt, *d_vv, *d_abc, *d_p0, *d_p1, *d_gp0, *d_gp1, *ptr, *d_dobs, *dobs, *transp;
	float *v0_slice, *v0_s, *v0_g, *vv_s, *vv_g, *d_vv_s, *d_vv_g;
	int N_image;
	int mig_s_x, mig_s_y;
	int mig_g_x, mig_g_y;
	int expends = 6;
	//float *d_p0_s, *d_p1_s;
	//float *d_gp0_g, *d_gp1_g,
	float *d_Isg, *d_Iss, *d_I1, *d_I2;
	float 	*h_boundary, *d_boundary;    /* boundary on host and device */
	int  ktt, i, j, k;




	int x0, y0, x1, y1, xd, xr0, yr0;
	int id;
	int nxr, nyr, nzr;
	int mig;
	float vmute;
	int  nss = 0;
	int nt_h, nt_d, nt_disk, ig;
	int index_sz, index_sy, index_sx, index_gz, index_gy, index_gx;
	int index_sx_xd, index_gx_xd;
	float m_boundary;
	float 	*disk_boundary;
	float k1, k2;
	int im;
	FILE  *fp_disk;   //save boundary
	fp_disk = fopen("boundary.bin", "wb");



	char *vfile = "";/* name of velocity file */
	FILE *vfp = NULL;
	MUSTGETPARSTRING("vfile", &vfile);
	int sx, sy, sz, gx, gy, gz;
	int oldsx, oldsy, oldsz, oldgx, oldgy, oldgz;
	float offset;
	int maxx = -1000, minx = 10000000, maxy = -1000, miny = 10000000;
	FILE *fp_forward, *fp_back, *fp_r, *fp_i1, *fp_i2;
	fp_forward = fopen("forward.bin", "wb");
	fp_back = fopen("back.bin", "wb");
	fp_i1 = fopen("I1.bin", "wb");
	fp_r = fopen("r.bin", "wb");
	fp_i2 = fopen("pp.bin", "wb");
	/* Hook up getpar to handle the parameters */


	/* Get info from first trace */
	if (!gettr(&intrace))  err("can't get first trace");

	if (!getparint("x_beg", &x_beg)) err("can't get x_beg");
	if (!getparint("y_beg", &y_beg)) err("can't get y_beg");
	if (!getparint("nss", &nss)) err("can't get nss");
	if (!getparint("nb", &nb)) err("can't get nb");
	if (!getparint("id", &id)) err("can't get device id");
	if (!getparint("dx", &ddx)) err("can't get ddx");  // must be type of int
	if (!getparint("dy", &ddy)) err("can't get ddy");
	if (!getparint("dz", &ddz)) err("can't get ddz");
	if (!getparfloat("fm", &fm)) err("can't get fm");
	if (!getparfloat("vmute", &vmute)) err("can't get vmute");
	//if (!getparint("nxr", &nxr)) err("can't get nxr");
	//if (!getparint("nyr", &nyr)) err("can't get nyr");
	//if (!getparint("nzr", &nzr)) err("can't get nzr");
	if (!getparint("ncdp", &ncdp)) err("can't get ncdp");
	if (!getparint("ninline", &ninline)) err("can't get ninline");
	if (!getparint("nz", &nz)) err("can't get nz");
	if (!getparint("line_range", &line_range)) err("can't get ine_range");
	if (!getparint("start_line", &start_line)) err("can't get start_line");
	if (!getparint("slice", &slice)) err("Whether slice");


	//  geometry
	x_min = x_beg + (start_line - 1 - line_range)*ddx;
	line_start = start_line - 1 - line_range;
	if ((start_line - 1 - line_range) < 0)
	{
		x_min = x_beg;
		line_start = 0;
	}
	y_min = y_beg;

	x_max = x_beg + (start_line - 1 + line_range)*ddx;
	line_last = start_line - 1 + line_range;
	if ((start_line - 1 + line_range) >= nline)
	{
		x_max = x_beg + (nline - 1)*ddx;
		line_last = nline - 1;
	}
	y_max = y_beg + （ncdp - 1）*ddy;

	x_image = x_beg + (start_line - 1)*ddx;
	i_x_image = (start_line);

	dx = 1.0 * ddx;
	dy = 1.0 * ddy;
	dz = 1.0 * ddz;
	nt = intrace.ns;
	dt = intrace.dt;
	dt = dt / 1000000;
	dt = 0.001;
	/* Store traces in tmpfile while getting a count of number of traces */
	_dz2 = 1.0 / (dz*dz);
	_dx2 = 1.0 / (dx*dx);
	_dy2 = 1.0 / (dy*dy);
	nbr = nb + radius;

	// read velocity, the sequence arranges in the  direction of cdp.
	float *vr, *v_slice;
	vr = (float*)malloc(ncdp*nz*(2 * line_range + 1) * sizeof(float));
	v_slice = (float*)malloc(ncdp*nz * sizeof(float));
	vfp = fopen(vfile, "rb");
	for (i = 0; i <= line_last; i++)    // inline adding
	{
		if (i < line_start)
		{
			fread(v_slice, sizeof(float), ncdp*nz, vfp);
		}
		if (i >= line_start && i <= line_last)
		{
			// velocity
			fread(&vr[(i - line_start)*nz*ncdp], sizeof(float), nz*ncdp, vfp);
		}

	}


	sf_check_gpu_error("Failed to initialize device before allocating !");
	cudaSetDevice(id);// initialize device, default device=0;
	sf_check_gpu_error("Failed to initialize device!");
	dim3 dimg, dimb;
	dim3 dimgtb, dimglr, dimgfr;
	dim3 dimgtb2, dimglr2, dimgfr2;

	dim3 dimg_s, dimb_s;
	dim3 dimgtb_s, dimglr_s, dimgfr_s;
	dim3 dimgtb2_s, dimglr2_s, dimgfr2_s;

	dim3 dimg_g, dimb_g;
	dim3 dimgtb_g, dimglr_g, dimgfr_g;
	dim3 dimgtb2_g, dimglr2_g, dimgfr2_g;



	float *trace;
	int *trace_gxy;
	int ntr = 5000;
	int flag_s = 0;
	int flag_g = 0;
	//tracet = (float*)malloc(nt*2000 *sizeof(float));
	trace = alloc1float(nt*ntr);
	trace_gxy = (int*)malloc(2 * ntr * sizeof(int));
	memset(trace, 0, nt*ntr * sizeof(float));
	memset(trace_gxy, 0, 2 * ntr * sizeof(int));

	///////// start for ///
	oldsx = intrace.sx;
	oldsy = intrace.sy;
	minx = oldsx;
	maxx = oldsx;
	miny = oldsy;
	maxy = oldsy;

	if (intrace.sx >= x_min && intrace.sx <= x_max && intrace.gx >= x_min && intrace.gx <= x_max)
	{
		if (intrace.sx >= x_image) flag_s = 1;
		if (intrace.gx >= x_image) flag_g = 1;
		if (!flag_s*flag_g)
		{
			trace_gxy[2 * ng] = intrace.gx;
			trace_gxy[2 * ng + 1] = intrace.gy;
			for (it = 0; it < nt; it++)
			{
				trace[nt*ng + it] = intrace.data[it];
			}
			ng++;
			ns++;
		}

	}
	//warn("begin   sx=%d sy=%d",oldsx,oldsy);
	do {
		// This step filters the shots according to the position of shots and receivers
		sx = intrace.sx;
		sy = intrace.sy;
		gx = intrace.gx;
		gy = intrace.gy;
		if (oldsx == sx && oldsy == sy)
		{
			if (intrace.sx >= x_min && intrace.sx <= x_max && intrace.gx >= x_min && intrace.gx <= x_max)
			{
				if (intrace.sx >= x_image) flag_s = 1;
				if (intrace.gx >= x_image) flag_g = 1;
				if (!flag_s*flag_g)
				{
					trace_gxy[2 * ng] = intrace.gx;
					trace_gxy[2 * ng + 1] = intrace.gy;
					for (it = 0; it < nt; it++)
					{
						trace[nt*ng + it] = intrace.data[it];
					}
					ng++;
				}

			}
			//warn("begin   sx=%d sy=%d ng=%d ns=%d nt=%d offset=%d \n",oldsx,oldsy,ng,ns,nt,intrace.offset);
		}
		else
		{
			if (ng > 20)
			{
				// check the shot and receiver point in the grid mesh
				for (i = 0; i < ng; i++)
				{
					if (trace_gxy[2 * i] >= maxx)
						maxx = trace_gxy[2 * i];
					if (trace_gxy[2 * i] <= minx)
						minx = trace_gxy[2 * i];
					if (trace_gxy[2 * i + 1] >= maxy)
						maxy = trace_gxy[2 * i + 1];
					if (trace_gxy[2 * i + 1] <= miny)
						miny = trace_gxy[2 * i + 1];
				}
				if (minx<x_image && maxx >x_image && minx >= x_min && maxx <= x_max)
				{
					// start RTM	

					dobs = alloc1float(nt*ng);
					memset(dobs, 0, nt*ng * sizeof(float));
					matrix_transpose(trace, dobs, nt, ng);

					if (oldsx < x_image)
					{
						flag_s = 0;
						flag_g = 1;
						nx_s = ((x_image - x_beg) / ddx) - ((minx - x_beg) / ddx) + 1 + expends;
						ny_s = ((maxy - y_beg) / ddy) - ((miny - y_beg) / ddy) + 1;
						nz_s = nz;
						nx_g = ((maxx - x_beg) / ddx) - ((x_image - x_beg) / ddx) + 1++expends;
						ny_g = ((maxy - y_beg) / ddy) - ((miny - y_beg) / ddy) + 1;
						nz_g = nz;
					}
					if (oldsx >= x_image)
					{
						flag_s = 1;
						flag_g = 0;
						nx_s = ((maxx - x_beg) / ddx) - ((x_image - x_beg) / ddx) + 1 + expends;
						ny_s = ((maxy - y_beg) / ddy) - ((miny - y_beg) / ddy) + 1;
						nz_s = nz;
						nx_g = ((x_image - x_beg) / ddx) - ((minx - x_beg) / ddx) + 1 + expends;
						ny_g = ((maxy - y_beg) / ddy) - ((miny - y_beg) / ddy) + 1;
						nz_g = nz;
					}
					nx = ((maxx - x_beg) / ddx) - ((minx - x_beg) / ddx);
					ny = ((maxy - y_beg) / ddy) - ((miny - y_beg) / ddy);
					warn("Migration shot=%d, ng=%d nx=%d, ny=%d nx_s=%d nx_g=%d\n ", ns, ng, nx, ny, nx_s, nx_g);

					nzb = nz + 2 * nb;
					nxb = nx + 2 * nb;
					nyb = ny + 2 * nb;
					nnz = nz + 2 * nbr;
					nnx = nx + 2 * nbr;
					nny = ny + 2 * nbr;
					N = nnx*nny*nnz;



					nzb_s = nz_s + 2 * nb;
					nxb_s = nx_s + 2 * nb;
					nyb_s = ny_s + 2 * nb;
					nnz_s = nz_s + 2 * nbr;
					nnx_s = nx_s + 2 * nbr;
					nny_s = ny_s + 2 * nbr;
					N_s = nny_s*nnz_s*nnx_s;

					nzb_g = nz_g + 2 * nb;
					nxb_g = nx_g + 2 * nb;
					nyb_g = ny_g + 2 * nb;
					nnz_g = nz_g + 2 * nbr;
					nnx_g = nx_g + 2 * nbr;
					nny_g = ny_g + 2 * nbr;
					N_g = nnx_g*nny_g*nnz_g;


					N_image = nny_s*nnz_s;
					/*
					v0 = alloc1float(nz*nx*ny);
					vv = alloc1float(N);
					memset(v0, 0, nx*ny*nz * sizeof(float));
					memset(vv, 0, nnx*nny*nnz * sizeof(float));
					*/
					v0_s = alloc1float(nz_s*nx_s*ny_s);
					vv_s = alloc1float(N_s);
					memset(v0_s, 0, nx_s*ny_s*nz_s * sizeof(float));
					memset(vv_s, 0, nnx_s*nny_s*nnz_s * sizeof(float));
					v0_g = alloc1float(nz_g*nx_g*ny_g);
					vv_g = alloc1float(N_g);
					memset(v0_g, 0, nx_g*ny_g*nz_g * sizeof(float));
					memset(vv_g, 0, nnx_g*nny_g*nnz_g * sizeof(float));


					dimg_s.x = (nzb_s + BlockSize1 - 1) / BlockSize1;
					dimg_s.y = (nxb_s + BlockSize2 - 1) / BlockSize2;
					dimb_s.x = BlockSize1;
					dimb_s.y = BlockSize2;
					dimgtb_s.x = (nnx_s + BlockSize1 - 1) / BlockSize1;
					dimgtb_s.y = (nny_s + BlockSize2 - 1) / BlockSize2;
					dimglr_s.x = (nnz_s + BlockSize1 - 1) / BlockSize1;
					dimglr_s.y = (nny_s + BlockSize2 - 1) / BlockSize2;
					dimgfr_s.x = (nnz_s + BlockSize1 - 1) / BlockSize1;
					dimgfr_s.y = (nnx_s + BlockSize2 - 1) / BlockSize2;
					dimgtb2_s.x = (nx_s + BlockSize1 - 1) / BlockSize1;
					dimgtb2_s.y = (ny_s + BlockSize2 - 1) / BlockSize2;
					dimglr2_s.x = (nz_s + BlockSize1 - 1) / BlockSize1;
					dimglr2_s.y = (ny_s + BlockSize2 - 1) / BlockSize2;
					dimgfr2_s.x = (nz_s + BlockSize1 - 1) / BlockSize1;
					dimgfr2_s.y = (nx_s + BlockSize2 - 1) / BlockSize2;


					dimg_g.x = (nzb_g + BlockSize1 - 1) / BlockSize1;
					dimg_g.y = (nxb_g + BlockSize2 - 1) / BlockSize2;
					dimb_g.x = BlockSize1;
					dimb_g.y = BlockSize2;
					dimgtb_g.x = (nnx_g + BlockSize1 - 1) / BlockSize1;
					dimgtb_g.y = (nny_g + BlockSize2 - 1) / BlockSize2;
					dimglr_g.x = (nnz_g + BlockSize1 - 1) / BlockSize1;
					dimglr_g.y = (nny_g + BlockSize2 - 1) / BlockSize2;
					dimgfr_g.x = (nnz_g + BlockSize1 - 1) / BlockSize1;
					dimgfr_g.y = (nnx_g + BlockSize2 - 1) / BlockSize2;
					dimgtb2_g.x = (nx_g + BlockSize1 - 1) / BlockSize1;
					dimgtb2_g.y = (ny_g + BlockSize2 - 1) / BlockSize2;
					dimglr2_g.x = (nz_g + BlockSize1 - 1) / BlockSize1;
					dimglr2_g.y = (ny_g + BlockSize2 - 1) / BlockSize2;
					dimgfr2_g.x = (nz_g + BlockSize1 - 1) / BlockSize1;
					dimgfr2_g.y = (nx_g + BlockSize2 - 1) / BlockSize2;

					//////////////////////////////////////////////////////////////////////
					cudaMalloc(&d_abc, nbr * sizeof(float));
					cudaMalloc(&d_wlt, nt * sizeof(float));
					cudaMalloc(&d_vv_s, nnz_s*nnx_s*nny_s * sizeof(float));
					cudaMalloc(&d_vv_g, nnz_g*nnx_g*nny_g * sizeof(float));
					cudaMalloc(&d_p0, nnz_s*nnx_s*nny_s * sizeof(float));
					cudaMalloc(&d_p1, nnz_s*nnx_s*nny_s * sizeof(float));
					cudaMalloc(&d_gp0, nnz_g*nnx_g*nny_g * sizeof(float));
					cudaMalloc(&d_gp1, nnz_g*nnx_g*nny_g * sizeof(float));
					cudaMalloc(&d_Iss, N_image * sizeof(float));
					cudaMalloc(&d_Isg, N_image * sizeof(float));
					cudaMalloc(&d_I1, N_image * sizeof(float));
					cudaMalloc(&d_I2, N_image * sizeof(float));
					cudaMalloc(&d_dobs, ng * sizeof(float));
					cudaMalloc(&d_szxy, 1 * sizeof(int));
					cudaMalloc(&d_gzxy, ng * sizeof(int));
					sf_check_gpu_error("Failed to initialize device memory of wave field!");
					m_boundary = 2.0 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s) * 4;
					nt_d = int(0 * 1024 * 1024 * 1024 / m_boundary);
					nt_h = int(20.0 * 1024 * 1024 * 1024 / m_boundary);
					if (nt_d > nt)
					{
						nt_d = nt;
						nt_h = 0;
						nt_disk = 0;
					}
					if (nt_d<nt && nt_d + nt_h >nt)
					{
						nt_h = nt - nt_d;
						nt_disk = 0;

					}
					if (nt_d<nt && nt_d + nt_h <nt)
					{

						nt_disk = nt - nt_d - nt_h;

					}
					//printf("nt=%d nt_d=%d nt_h=%d nt_disk=%d nt_all=%d \n", nt, nt_d, nt_h, nt_disk, nt_d + nt_h + nt_disk);
					warn("nt=%d nt_d=%d nt_h=%d nt_disk=%d nt_all=%d \n", nt, nt_d, nt_h, nt_disk, nt_d + nt_h + nt_disk);

					cudaHostAlloc(&h_boundary, nt_h * 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s) * sizeof(float), cudaHostAllocMapped);
					cudaHostAlloc(&disk_boundary, 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s) * sizeof(float), cudaHostAllocMapped);
					cudaMalloc(&d_boundary, (nt_d) * 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s) * sizeof(float));
					cudaMemset(h_boundary, 0, nt_h * 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s) * sizeof(float));
					cudaMemset(d_boundary, 0, (nt_d) * 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s) * sizeof(float));
					cudaMemset(disk_boundary, 0, 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s) * sizeof(float));
					cudaMemset(d_I1, 0, N_image * sizeof(float));
					cudaMemset(d_I2, 0, N_image * sizeof(float));
					cudaMemset(d_Iss, 0, N_image * sizeof(float));
					cudaMemset(d_Isg, 0, N_image * sizeof(float));
					sf_check_gpu_error("Failed to allocate memory for variables!");
					cuda_ricker_wavelet << <(nt + 511) / 512, 512 >> >(d_wlt, fm, dt, nt);
					cuda_abc << <nbr + 15, 16 >> >(d_abc, nbr);

					///Loading velocity for shot simulator and receiver simulator///////////////////////
					cudaEventRecord(start);
					fseek(fp_disk, 0, SEEK_SET);

					// shot block
					if (flag_s)
					{
						//right shot
						i_x_s_beg = ((x_image - x_beg) / ddx) - expends;    // i_x is related to local velocity model
						i_y_s_beg = ((miny - y_beg) / ddy);
						//mig_s = (i_x_s - start_line)*nz + i_y_s*nz*(2 * line_range + 1);
						//x_beg + (start_line - 1 - line_range)*ddx;
						//line_start = start_line - 1 - line_range;
						mig_s_x = i_x_s_beg - (x_min - x_beg) / ddx;
						mig_s_y = i_y_s_beg - (y_min - y_beg) / ddx;
					}
					else
					{
						// left shot
						i_x_s_beg = ((minx - x_beg) / ddx);    // i_x is related to local velocity model
						i_y_s_beg = ((miny - y_beg) / ddy);
						//mig_s = (i_x_s - line_start)*nz + i_y_s*nz*(2 * line_range + 1);
						mig_s_x = i_x_s_beg - (x_min - x_beg) / ddx;
						mig_s_y = i_y_s_beg - (y_min - y_beg) / ddx;
					}

					// receiver block
					if (flag_g)
					{
						//right shot
						i_x_g_beg = ((x_image - x_beg) / ddx) - expends;    // i_x is related to local velocity model
						i_y_g_beg = ((miny - y_beg) / ddy);
						mig_g_x = i_x_g_beg - (x_min - x_beg) / ddx;
						mig_g_y = i_y_g_beg - (y_min - y_beg) / ddx;
						//mig_g = (i_x_g - start_line)*nz + i_y_g*nz*(2 * line_range + 1);

					}
					else
					{
						// left shot
						i_x_g_beg = ((minx - x_beg) / ddx);    // i_x is related to local velocity model
						i_y_g_beg = ((miny - y_beg) / ddy);
						//mig_g = (i_x_g - line_start)*nz + i_y_g*nz*(2 * line_range + 1);
						mig_g_x = i_x_g_beg - (x_min - x_beg) / ddx;
						mig_g_y = i_y_g_beg - (y_min - y_beg) / ddx;
					}

					// load velocity of shot block
					for (i = 0; i < ny_s; i++)
						for (j = 0; j < nx_s; j++)
							for (k = 0; k < nz_s; k++)
							{
								//v0[k + j*nz + i*nz*nx] = vr[mig + k + j*nzr + i*nzr*nxr];
								//v0[k + j*nz + i*nz*nx]=2000+k*10;
								//v0[k + j*nz + i*nz*nx] = 2500 + k * 10;
								// if( k>170)   v0[k + j*nz + i*nz*nx]=4500;
								v0_s[k + j*nz_s + i*nz_s*nx_s] = vr(mig_s_x*nz*ncdp + mig_s_y*nz + k + j*nz*ncdp + i*nz);
							}

					// load velocity of receiver block
					for (i = 0; i < ny_g; i++)
						for (j = 0; j < nx_g; j++)
							for (k = 0; k < nz_g; k++)
							{
								//v0[k + j*nz + i*nz*nx] = vr[mig + k + j*nzr + i*nzr*nxr];
								//v0[k + j*nz + i*nz*nx]=2000+k*10;
								//v0[k + j*nz + i*nz*nx] = 2500 + k * 10;
								// if( k>170)   v0[k + j*nz + i*nz*nx]=4500;
								v0_g[k + j*nz_g + i*nz_g*nx_g] = vr(mig_g_x*nz*ncdp + mig_g_y*nz + k + j*nz*ncdp + i*nz);
							}
					// extend the velocity
					extend3d(v0_s, vv_s, nz_s, nx_s, ny_s, nb);
					velocity_transform(vv_s, dt, dz, dx, dy, nz_s, nx_s, ny_s, nb);
					cudaMemcpy(d_vv_s, vv_s, nnz_s*nnx_s*nny_s * sizeof(float), cudaMemcpyHostToDevice);
					extend3d(v0_g, vv_g, nz_g, nx_g, ny_g, nb);
					velocity_transform(vv_g, dt, dz, dx, dy, nz_g, nx_g, ny_g, nb);
					cudaMemcpy(d_vv_g, vv_g, nnz_g*nnx_g*nny_g * sizeof(float), cudaMemcpyHostToDevice);


					for (ig = 0; ig < ng; ig++)
					{
						index_gx = (trace_gxy[2 * ig] - x_beg) / ddx - i_x_g_beg;
						index_gy = (trace_gxy[2 * ig + 1] - y_beg) / ddy - i_y_g_beg;
						index_gz = 2;
						index_gx_image = (x_image - x_beg) / ddx - i_x_g_beg;
						cuda_set_gzxy << <1, 1 >> >(d_gzxy, index_gz, index_gx, index_gy, ig, nz_g, nx_g, ny_g, nb);


						index_sx = (oldsx - x_beg) / ddx - i_x_s_beg;
						index_sy = (oldsy - y_beg) / ddy - i_y_s_beg;
						index_sx_image = (x_image - x_beg) / ddx - i_x_s_beg;
						index_sz = 1
							//index_sx = 150;
							//index_sy = 150;
					}
					warn("index_sx=%d  index_sy=%d  index_sx_image=%d index_gx_image= %d \n", ns, index_sx, index_sy, index_sx_image, index_gx_image);

					nt_image = (int)(1.0*abs(oldsx - x_image) / vmute) - 100;
					if (nt_image > nt)
					{
						warn("nt_image error =%d \n", nt_image);
					}
					else
					{
						warn("nt_image =%d \n", nt_image);
					}
					cuda_set_szxy << <1, 1 >> >(d_szxy, index_sz, index_sx, index_sy, 0, nz_s, nx_s, ny_s, nb);
					//matrix_transpose(transp, dobs, nt, ng);

					cudaMemset(d_Isg, 0, N_image * sizeof(float));
					cudaMemset(d_Iss, 0, N_image * sizeof(float));
					//cudaMemset(h_boundary, 0, nt_h * 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s) * sizeof(float));
					//cudaMemset(d_boundary, 0, (nt - nt_h) * 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s) * sizeof(float));
					cudaMemset(d_p0, 0, nnz_s*nnx_s*nny_s * sizeof(float));
					cudaMemset(d_p1, 0, nnz_s*nnx_s*nny_s * sizeof(float));

					cudaMemset(d_dobs, 0, ng * sizeof(float));
					//cudaMemcpy(d_dobs, dobs, ng*nt * sizeof(float), cudaMemcpyHostToDevice);
					for (it = 0; it<nt; it++) {
						cuda_add_source << <1, 1 >> >(true, d_p1, &d_wlt[it], &d_szxy[0], 1);
						cuda_step_fd3d << <dimg_s, dimb_s >> >(d_p0, d_p1, d_vv_s, _dz2, _dx2, _dy2, nzb_s, nxb_s, nyb_s);
						apply_sponge_tb << <dimgtb_s, dimb_s >> >(d_p0, d_abc, nz_s, nx_s, ny_s, nb);
						apply_sponge_lr << <dimglr_s, dimb_s >> >(d_p0, d_abc, nz_s, nx_s, ny_s, nb);
						apply_sponge_fr << <dimgfr_s, dimb_s >> >(d_p0, d_abc, nz_s, nx_s, ny_s, nb);

						apply_sponge_tb << <dimgtb_s, dimb_s >> >(d_p1, d_abc, nz_s, nx_s, ny_s, nb);
						apply_sponge_lr << <dimglr_s, dimb_s >> >(d_p1, d_abc, nz_s, nx_s, ny_s, nb);
						apply_sponge_fr << <dimgfr_s, dimb_s >> >(d_p1, d_abc, nz_s, nx_s, ny_s, nb);

						ptr = d_p0; d_p0 = d_p1; d_p1 = ptr;

						if (slice && it % 100 == 0)
						{
							//cuda_record << <(ng + 255) / 256, 256 >> >(d_p0, d_dobs, d_gzxy, ng);
							//cuda_mute << <dimgtb2, dimb >> >(d_dobs, &d_szxy[is], d_gzxy, it, 130, 2600, dt, dz, dx, dy, nz, nx, ny, nb, ng, 1);
							//cudaMemcpy(&dobs[it*ng], d_dobs, ng * sizeof(float), cudaMemcpyDeviceToHost);
							cudaMemcpy(vv_s, d_p0, nnz_s*nnx_s*nny_s * sizeof(float), cudaMemcpyDeviceToHost);
							window3d(v0_s, vv_s, nz_s, nx_s, ny_s, nb)
								for (i = 0; i<ncdp; i++)
									for (j = 0; j < nz_s; j++)
									{
										v_slice[j + i*nz_s] = v0_s[j + i*nz_s*nx_s];
									}
							fwrite(v_slice, sizeof(float), ncdp*nz, fp_forward);
						}
						if (it<nt_h) cudaHostGetDevicePointer(&ptr, &h_boundary[it * 2 * (nx_s*ny_s + ny_s*nz_s + nz_s*nx_s)], 0);
						if (it >= nt_h && it<nt_h + nt_d) ptr = &d_boundary[(it - nt_h) * 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s)];
						if (it >= nt_h + nt_d && it < nt)
						{
							cudaHostGetDevicePointer(&ptr, disk_boundary, 0);
						}
						cuda_rw_innertb << <dimgtb2_s, dimb_s >> >(ptr, d_p0, nz_s, nx_s, ny_s, nb, false);
						cuda_rw_innerlr << <dimglr2_s, dimb_s >> >(&ptr[2 * nx_s*ny_s], d_p0, nz_s, nx_s, ny_s, nb, false);
						cuda_rw_innerfr << <dimgfr2_s, dimb_s >> >(&ptr[2 * (nx_s*ny_s + ny_s*nz_s)], d_p0, nz_s, nx_s, ny_s, nb, false);
						if (it >= nt_h + nt_d && it <nt)
						{
							fwrite(disk_boundary, sizeof(float), 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s), fp_disk);

						}
						/*
						if (it == 949)
						{
						cudaMemcpy(vv, d_p0, nnz*nnx*nny * sizeof(float), cudaMemcpyDeviceToHost);
						window3d(v0, vv, nz, nx, ny, nb);
						//fwrite(v0, sizeof(float), nx*ny*nz, fp_p);
						for (i = 0; i<ny; i++)
						for (j = 0; j<nz; j++)
						fwrite(&v0[150 * nz + i*nz*nx + j], sizeof(float), 1, fp_p);
						}
						*/

						if (it % 100 == 0)
							warn("it=%d \n", it);
					}



					fwrite(disk_boundary, sizeof(float), 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s), fp_disk);
					ptr = d_p0; d_p0 = d_p1; d_p1 = ptr;
					cudaMemset(d_gp0, 0, nnz_g*nnx_g*nny_g * sizeof(float));
					cudaMemset(d_gp1, 0, nnz_g*nnx_g*nny_g * sizeof(float));
					//cudaMemcpy(transp, d_dobs, nt*ng * sizeof(float), cudaMemcpyDeviceToHost);
					//matrix_transpose(dobs, transp, ng, nt);
					fwrite(dobs, sizeof(float), nt*ng, fp_r);
					ktt = 0;
					for (it = nt - 1; it>nt_image; it--)
					{
						ktt++;
						if (it<nt_h) cudaHostGetDevicePointer(&ptr, &h_boundary[it * 2 * (nx_s*ny_s + ny_s*nz_s + nz_s*nx_s)], 0);
						if (it >= nt_h && it<nt_h + nt_d)  ptr = &d_boundary[(it - nt_h) * 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s)];
						if (it >= nt_h + nt_d && it < nt)
						{
							fseek(fp_disk, -2L * sizeof(disk_boundary), SEEK_CUR);
							fread(disk_boundary, sizeof(float), 2 * (nx_s*ny_s + nx_s*nz_s + ny_s*nz_s), fp_disk);
							cudaHostGetDevicePointer(&ptr, disk_boundary, 0);
							warn("disk it=%d !! \n", it);
						}
						cuda_rw_innertb << <dimgtb2_s, dimb_s >> >(ptr, d_p1, nz_s, nx_s, ny_s, nb, true);
						cuda_rw_innerlr << <dimglr2_s, dimb_s >> >(&ptr[2 * nx_s*ny_s], d_p1, nz_s, nx_s, ny_s, nb, true);
						cuda_rw_innerfr << <dimgfr2_s, dimb_s >> >(&ptr[2 * (nx_s*ny_s + ny_s*nz_s)], d_p1, nz_s, nx_s, ny_s, nb, true);

						cuda_step_fd3d << <dimg_s, dimb_s >> >(d_p0, d_p1, d_vv_s, _dz2, _dx2, _dy2, nzb_s, nxb_s, nyb_s);
						cuda_add_source << <1, 1 >> >(false, d_p1, &d_wlt[it], &d_szxy[0], 1);
						ptr = d_p0; d_p0 = d_p1; d_p1 = ptr;

						cudaMemcpy(d_dobs, &dobs[it*ng], ng * sizeof(float), cudaMemcpyHostToDevice);
						cuda_add_source << <(ng + 255) / 256, 256 >> >(true, d_gp0, d_dobs, d_gzxy, ng);
						cuda_step_fd3d << <dimg_g, dimb_g >> >(d_gp0, d_gp1, d_vv_g, _dz2, _dx2, _dy2, nzb_g, nxb_g, nyb_g);

						apply_sponge_tb << <dimgtb_g, dimb_g >> >(d_gp0, d_abc, nz_g, nx_g, ny_g, nb);
						apply_sponge_lr << <dimglr_g, dimb_g >> >(d_gp0, d_abc, nz_g, nx_g, ny_g, nb);
						apply_sponge_fr << <dimgfr_g, dimb_g >> >(d_gp0, d_abc, nz_g, nx_g, ny_g, nb);

						apply_sponge_tb << <dimgtb_g, dimb_g >> >(d_gp1, d_abc, nz_g, nx_g, ny_g, nb);
						apply_sponge_lr << <dimglr_g, dimb_g >> >(d_gp1, d_abc, nz_g, nx_g, ny_g, nb);
						apply_sponge_fr << <dimgfr_g, dimb_g >> >(d_gp1, d_abc, nz_g, nx_g, ny_g, nb);

						ptr = d_gp0; d_gp0 = d_gp1; d_gp1 = ptr;

						if (slice && it % 100 == 0)
						{
							//cuda_record << <(ng + 255) / 256, 256 >> >(d_p0, d_dobs, d_gzxy, ng);
							//cuda_mute << <dimgtb2, dimb >> >(d_dobs, &d_szxy[is], d_gzxy, it, 130, 2600, dt, dz, dx, dy, nz, nx, ny, nb, ng, 1);
							//cudaMemcpy(&dobs[it*ng], d_dobs, ng * sizeof(float), cudaMemcpyDeviceToHost);
							cudaMemcpy(vv_s, d_gp0, nnz_s*nnx_s*nny_s * sizeof(float), cudaMemcpyDeviceToHost);
							window3d(v0_s, vv_s, nz_s, nx_s, ny_s, nb)
								for (i = 0; i<ncdp; i++)
									for (j = 0; j < nz_s; j++)
									{
										v_slice[j + i*nz_s] = v0_s[j + i*nz_s*nx_s];
									}
							fwrite(v_slice, sizeof(float), ncdp*nz, fp_back);
						}
						/*
						if (it >nt / 12 * 7 && it % 30 == 0)
						{
						cudaMemcpy(vv, d_gp0, nnz*nnx*nny * sizeof(float), cudaMemcpyDeviceToHost);
						window3d(v0, vv, nz, nx, ny, nb);
						//fwrite(v0, sizeof(float), nx*ny*nz, fp_p);
						for (i = 0; i<ny; i++)
						for (j = 0; j<nz; j++)
						fwrite(&v0[70 * nz + i*nz*nx + j], sizeof(float), 1, fp_p);
						}
						if (it >nt / 12 * 7 && it % 30 == 0)
						{
						cudaMemcpy(vv, d_p0, nnz*nnx*nny * sizeof(float), cudaMemcpyDeviceToHost);
						window3d(v0, vv, nz, nx, ny, nb);
						//fwrite(v0, sizeof(float), nx*ny*nz, fp_p);
						for (i = 0; i<ny; i++)
						for (j = 0; j<nz; j++)
						fwrite(&v0[70 * nz + i*nz*nx + j], sizeof(float), 1, fp_i2);
						}
						*/

						if (ktt >(nt - nt_image) - 200)
						{
							//cuda_cross_correlate << <dimgfr, dimb >> >(d_Isg, d_Iss, d_p0, d_gp0, nz, nx, ny, nb);
							cuda_cross_correlate_oneinlin << <dimglr_g, dimb_g >> >(d_Isg, d_Iss, d_p0, d_gp0, nz_s, nx_s, ny_s, nz_g, nx_g, ny_g, index_sx_image, index_gx_image, nb);
						}

						if (it % 100 == 0)
							warn("it=%d \n", it);
					}
					// finished one shots;

					//cuda_imaging << <dimgfr, dimb >> >(d_Isg, d_Iss, d_I1, d_I2, nz, nx, ny, nb);
					//cuda_imaging22 << <dimgfr, dimb >> >(d_Isg, d_Iss, d_p0, d_gp0, nz, nx, ny, nb);
					//cuda_laplace_filter3d << <dimgfr, dimb >> >(d_p0, d_Isg, 1. / dz, 1. / dx, 1. / dy, nz, nx, ny, nb);

					cuda_imaging_oneinlin << <dimglr_g, dimb_g >> >(d_Isg, d_Iss, d_I1, d_I2, nz_s, nx_s, ny_s, nz_g, nx_g, ny_g, index_sx_image, index_gx_image, nb);
					cuda_laplace_filter2d << <dimglr_g, dimb_g >> >(d_I1, d_Isg, 1. / dz, 1. / dy, nb, nz_s, ny_s);
					//cuda_laplace_filter2d(float *Img, float *laplace, float _dz, float _dy, int nb, int nz, int ny)
					cudaMemcpy(v_slice, d_Isg, nnz_s*nny_s * sizeof(float), cudaMemcpyDeviceToHost);
					window2d(v0_s, v_slice, nz_s, ny_s, nb);


					cudaEventRecord(stop);
					cudaEventSynchronize(stop);
					cudaEventElapsedTime(&mstimer, start, stop);
					warn("%d shot finished : %g(s) \n", ns, mstimer*1.e-3);


					// write file
					//cudaMemcpy(vv, d_Isg, nnz*nnx*nny * sizeof(float), cudaMemcpyDeviceToHost);
					//window3d(v0, vv, nz, nx, ny, nb);
					for (i = 0; i<ny_s; i++)
					{
						erewind(hfp);
						intrace.ns = nz;
						efwrite(&intrace, HDRBYTES, 1, hfp);
						erewind(hfp);
						efwrite(&outtrace, HDRBYTES, 1, hfp);
						outtrace.sx = x_image;
						outtrace.sy = miny + i*ddy;
						outtrace.cdp = i_y_s_beg + i;
						outtrace.fldr = i_x_image;
						for (k = 0; k < nz; k++)
						{
							outtrace.data[k] = v0_g[k + i*nz_s];
							//v0[k + j*nz*nx + i * nz];

						}

						puttr(&outtrace);
					}
				}// if zone






			} // if ns>20



			  ///////////////////////////////////////////End of RTM and set  trace array to zero///////////////////////////////////////////////////////
			memset(trace, 0, nt*ntr * sizeof(float));
			memset(trace_gxy, 0, 2 * ntr * sizeof(int));
			ns++;
			ng = 0;
			oldsx = sx;
			oldsy = sy;
			minx = oldsx;
			maxx = oldsx;
			miny = oldsy;
			maxy = oldsy;
			if (intrace.sx >= x_min && intrace.sx <= x_max && intrace.gx >= x_min && intrace.gx <= x_max)
			{
				if (intrace.sx >= x_image) flag_s = 1;
				if (intrace.gx >= x_image) flag_g = 1;
				if (!flag_s*flag_g)
				{
					trace_gxy[2 * ng] = intrace.gx;
					trace_gxy[2 * ng + 1] = intrace.gy;
					for (it = 0; it < nt; it++)
					{
						trace[nt*ng + it] = intrace.data[it];
					}
					ng = 1;
				}

			}
			/*
			if (intrace.sx >= x0 && intrace.sx <= x1 && intrace.gx >= x0 && intrace.gx <= x1)
			{
			trace_gxy[2 * ng] = intrace.gx;
			trace_gxy[2 * ng + 1] = intrace.gy;
			for (it = 0; it < nt; it++)
			{
			trace[nt*ng + it] = intrace.data[it];
			}
			ng++;
			}
			*/
			/*
			cudaMemcpy(vv, d_Isg, nnz*nnx*nny * sizeof(float), cudaMemcpyDeviceToHost);
			window3d(v0, vv, nz, nx, ny, nb);
			im = nx / 3;

			for (i = 0; i<ny; i++)
			for (k = im; k<2 * im; k++)
			for (j = 0; j<nz; j++)
			fwrite(&v0[k*nz + i*nz*nx + j], sizeof(float), 1, fp_i1);
			*/
			// write su file
			/*
			for (i = 0; i<ny; i++)
			for (j = im; j < 2 * im; j++)
			{
			for (k = 0; k < nz; k++)
			{
			intrace.data[k] = v0[k + j*nz + i*nz*nx];
			}
			intrace.sx = (i_x + j)*ddx;
			intrace.sy = (i_y + i)*ddy;
			intrace.cdp = i_x + i_y*nxr;

			puttr(&intrace);
			}


			*/
			/*
			memset(tracet, 0, nt*ntr * sizeof(float));
			memset(trace_gxy, 0, 2 * ntr * sizeof(int));

			ns++;
			ng = 0;
			oldsx = sx;
			oldsy = sy;
			trace_gxy[2 * ng] = intrace.gx;
			trace_gxy[2 * ng + 1] = intrace.gy;
			ng++;
			*/
		}

	} while (gettr(&intrace) && ns <= nss);

	warn(" success !  \n ");

	checkpars();
	return(CWP_Exit());
}
